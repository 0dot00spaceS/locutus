var glob = require('glob')
var globby = require('globby')
var path = require('path')
var fs = require('fs')
var YAML = require('js-yaml')
var mkdirp = require('mkdirp')

function flatten () {
  var flat = []
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i] instanceof Array) {
      flat.push.apply(flat, flatten.apply(this, arguments[i]))
    } else {
      flat.push(arguments[i])
    }
  }
  return flat
}

function LocutusUtil (config) {
  this.injectDependencies = []

  // Overwrite properties with config
  for (var k in config) {
    this[k] = config[k]
  }
}

// Should be overridden by a more sofisticated function
// such as cli.debug when run in node.js
LocutusUtil.prototype.debug = function (a) {
  return console.log(a)
}

// Should be overridden by a more sofisticated function
// such as assert.deepEqual when run in node.js
LocutusUtil.prototype.equal = function (a, b) {
  return JSON.stringify(a) === JSON.stringify(b)
}

// Environment-specific file opener. function name needs to
// be translated to code. The difficulty is in finding the
// category.
LocutusUtil.prototype.opener = function (fileOrName, cb) {
  var self = this
  var pattern = fileOrName
  if (fileOrName.indexOf('/') === -1) {
    pattern = self.__src + '/*/*/' + fileOrName + '.js'
  }

  glob(pattern, {}, function (err, files) {
    if (err) {
      return self.error('Could not glob for ' + pattern + '. ' + err)
    }

    if (files.length !== 1) {
      return cb('Found ' + files.length + ' occurances of ' + fileOrName + ' via pattern: ' + pattern)
    }

    var filepath = files[0]

    if (path.basename(filepath) === 'index.js') {
      return cb(null)
    }

    if (!filepath) {
      return cb('Could not find ' + pattern)
    }

    fs.readFile(filepath, 'utf-8', function (err, code) {
      if (err) {
        return cb('Error while opening ' + filepath + '. ' + err)
      }
      return cb(null, code)
    })
  })
}

LocutusUtil.prototype.injectweb = function (args, options) {
  var self = this
  var pattern = self.__src + '/' + options.language + '/' + options.category + '/' + options.name + '.js'

  self.glob(pattern, function (err, params, file) {
    if (err) {
      return self.error('Could not glob for ' + pattern + '. ' + err)
    }

    var authors = {}
    var keys = ['original by', 'improved by', 'bugfixed by', 'revised by', 'input by']
    keys.forEach(function (key) {
      if (params.headKeys[key]) {
        authors[key] = flatten(params.headKeys[key])
      }
    })

    var webfuncPath = self.__root + '/website/_functions/' + params.language + '/' + params.category + '/' + params.func_name + '.html'
    var data = {
      warning: 'This file is auto generated by `npm run web:inject`, do not edit by hand',
      examples: (params.headKeys.example || []).map(function (lines, i) { return lines.join('\n') }),
      returns: (params.headKeys.returns || []).map(function (lines, i) { return lines.join('\n') }),
      dependencies: flatten(params.headKeys['depends on'] || []),
      authors: authors || {},
      notes: (params.headKeys.note || []).map(function (lines, i) { return lines.join('\n') }),
      layout: 'function',
      function: params.func_name,
      category: params.category,
      language: params.language,
      permalink: params.language + '/' + params.category + '/' + params.func_name + '/',
      redirect_from: [
        '/functions/' + params.language + '/' + params.func_name + '/',
        '/functions/' + params.category + '/' + params.func_name + '/',
        '/' + params.language + '/' + params.func_name + '/'
      ]
    }

    if (params.language === 'php') {
      data.redirect_from.push('/functions/' + params.func_name + '/')
    }

    try {
      var yml = YAML.safeDump(data).trim()
    } catch (e) {
      console.dir(data)
      throw new Error('Unable to form valid YAML of above data. ' + e)
    }
    var buf = '---' + '\n' + yml + '\n' + '---' + '\n'

    buf += params.code

    mkdirp(path.dirname(webfuncPath), function (err) {
      if (err) {
        return self.error('Could not mkdir  for ' + webfuncPath + '. ' + err)
      }
      fs.writeFileSync(webfuncPath, buf)
    })
  })
}

LocutusUtil.prototype.glob = function (pattern, workerCb) {
  var bailed = false
  var self = this
  glob(pattern, {}, function (err, files) {
    if (bailed) {
      return
    }
    if (err) {
      bailed = true
      return workerCb(err)
    }
    var names = []
    for (var i in files) {
      var file = files[i]
      var name = path.basename(file, '.js')
      if (file.indexOf('/_') === -1 && name !== 'index') {
        names.push({name: name, file: file})
      }
    }
    names.forEach(function (props) {
      self.load(props.file, function (err, params) {
        if (err) {
          bailed = true
          return workerCb(err)
        }

        return workerCb(null, params, props.file)
      })
    })
  })
}

LocutusUtil.prototype.test = function (args, options) {
  var self = this
  var pattern = self.__src + '/' + options.language + '/' + options.category + '/' + options.name + '.js'
  self.pass_cnt = 0
  self.know_cnt = 0
  self.fail_cnt = 0
  self.skip_cnt = 0

  process.on('exit', function () {
    var msg = self.pass_cnt + ' passed / ' + self.fail_cnt + ' failed  / ' + self.know_cnt + ' known / ' + self.skip_cnt + ' skipped'
    if (self.fail_cnt) {
      self.cli.fatal(msg)
    } else {
      self.cli.ok(msg)
    }
  })

  var knownFailures = fs.readFileSync(self.__src + '/php/known-failures.txt', 'utf-8').trim('').split('\n')

  self.glob(pattern, function (err, params, file) {
    if (err) {
      return self.error('Could not glob for ' + pattern + '. ' + err)
    }

    if (params.headKeys.test && params.headKeys.test[0][0] === 'skip') {
      self.skip_cnt++
      return self.cli.info('--> ' + params.name + ' skipped as instructed. ')
    }

    self._test(params, function (err, test, params) {
      var testName = params.func_name + '#' + (+(test.number * 1) + 1)
      if (!err) {
        self.pass_cnt++
        self.cli.debug('--> ' + testName + ' passed. ')
      } else {
        if (knownFailures.indexOf(testName) > -1) {
          self.cli.error('--> ' + testName + ' known error. ')
          self.cli.error(err)
          self.know_cnt++
        } else {
          self.cli.error('--> ' + testName + ' failed. ')
          self.cli.error(err)
          self.fail_cnt++
          if (options.abort) {
            self.cli.fatal('Aborting on first failure as instructed. ')
          }
        }
      }
    })
  })
}

LocutusUtil.prototype._commentBlocks = function (code) {
  var cnt = 0
  var comment = []
  var commentBlocks = []
  var i = 0
  var lines = []
  var raise = false
  for (i in (lines = code.replace('\r', '').split('\n'))) {
    // Detect if line is a comment, and return the actual comment
    if ((comment = lines[i].match(/^\s*(\/\/|\/\*|\*)\s*(.*)$/))) {
      if (raise === true) {
        cnt = commentBlocks.length
        raise = false
      }
      if (!commentBlocks[cnt]) {
        commentBlocks[cnt] = {clean: [], raw: []}
      }

      commentBlocks[cnt].clean.push(comment[2].trim())
      commentBlocks[cnt].raw.push(lines[i])
    } else {
      raise = true
    }
  }

  return commentBlocks
}

LocutusUtil.prototype._headKeys = function (headLines) {
  var i
  var keys = {}
  var match = []
  var dmatch = []
  var key = ''
  var val = ''
  var num = 0

  for (i in headLines) {
    if (!(match = headLines[i].match(/^\s*\W?\s*([a-z\ 0-9]+)\s*:\s*(.*)\s*$/))) {
      continue
    }
    key = match[1]
    val = match[2]

    if ((dmatch = key.match(/^(\w+)\s+(\d+)$/))) {
      // Things like examples and notes can be grouped
      key = dmatch[1]
      num = dmatch[2] - 1
    } else {
      num = 0
    }

    if (!keys[key]) {
      keys[key] = []
    }
    if (!keys[key][num]) {
      keys[key][num] = []
    }
    keys[key][num].push(val)
  }

  return keys
}

LocutusUtil.prototype.contains = function (array, value) {
  var i = array.length
  while (i--) {
    if (array[i] === value) {
      return true
    }
  }
  return false
}

LocutusUtil.prototype._loadDependencies = function (name, headKeys, dependencies, cb) {
  var self = this

  if (!headKeys['depends on'] || !headKeys['depends on'].length) {
    if (cb) {
      cb(null, {})
    }
  }

  var i
  var depname
  var loaded = 0
  for (i in headKeys['depends on']) {
    depname = headKeys['depends on'][i][0]

    self.load(depname, function (err, params) {
      if (err) {
        return cb(err)
      }

      dependencies[depname] = params
      self._loadDependencies(depname, params.headKeys, dependencies)

      if (cb && ++loaded === headKeys['depends on'].length) {
        cb(null, dependencies)
      }
    })
  }
}

LocutusUtil.prototype.parse = function (fileOrName, code, cb) {
  if (!code) {
    throw new Error('Unable to parse ' + fileOrName)
  }

  var category
  var language

  if (fileOrName.indexOf('/') === -1) {
    language = false
    category = false
  } else {
    var parts = fileOrName.split('/')
    var basefile = parts.pop()
    category = parts.pop()
    language = parts.pop()
  }

  var patFuncStart = /^\s*module\.exports = function\s*([^\s)]+)\s*\(([^\)]*)\)\s*\{\s*/i
  var patFuncEnd = /\s*}\s*$/
  var commentBlocks = this._commentBlocks(code)

  if (!commentBlocks[0]) {
    throw new Error('Unable to parse ' + fileOrName)
  }

  var head = commentBlocks[0].raw.join('\n')
  var body = code.replace(head, '')
  body = body.replace(patFuncStart, '')
  body = body.replace(patFuncEnd, '')
  var headKeys = this._headKeys(commentBlocks[0].clean)

  // Parse fucntion signature
  var funcSigMatch = code.match(patFuncStart)
  if (!funcSigMatch) {
    throw new Error('Unable to parse ' + name)
  }

  var params = {
    headKeys      : headKeys,
    body          : body,
    head          : head,
    name          : fileOrName,
    code          : code,
    language      : language,
    category      : category,
    func_signature: funcSigMatch[0],
    func_name     : funcSigMatch[1],
    func_arguments: funcSigMatch[2].split(/,\s*/),
    commentBlocks : commentBlocks
  }

  this._loadDependencies(funcSigMatch[1], headKeys, {}, function (err, dependencies) {
    if (err) {
      return cb(err)
    }

    params.dependencies = dependencies
    return cb(null, params)
  })
}

LocutusUtil.prototype.loadMultiple = function (names, cb) {
  var self = this
  var paramsMultiple = {}
  var loaded = 0
  for (var i in names) {
    var name = names[i]
    self.load(name, function (err, params) {
      if (err) {
        return cb(err)
      }

      paramsMultiple[params.name] = params

      if (++loaded === names.length) {
        // console.log('loaded: ' + name)
        // console.log(paramsMultiple)
        return cb(null, paramsMultiple)
      }
    })
  }
}

LocutusUtil.prototype.load = function (fileOrName, cb) {
  var self = this
  self.opener(fileOrName, function (err, code) {
    if (err) {
      return cb(err)
    }

    self.parse(fileOrName, code, cb)
  })
}

LocutusUtil.prototype.unique = function (array) {
  var a = array.concat()

  for (var i = 0; i < a.length; ++i) {
    for (var j = i + 1; j < a.length; ++j) {
      if (a[i] === a[j]) {
        a.splice(j--, 1)
      }
    }
  }

  return a
}

LocutusUtil.prototype.getRecursiveCode = function (params) {
  var self = this
  var codez = []

  if ('name' in params) {
    codez.push(params.code)
    for (var d in params.dependencies) {
      codez = codez.concat(self.getRecursiveCode(params.dependencies[d]))
    }
  }

  codez = codez.reverse()

  return codez
}

LocutusUtil.prototype._test = function (params, cb) {
  var self = this
  var codez = []

  self.loadMultiple(self.injectDependencies, function (err, paramsMultiple) {
    codez.unshift('locutus = {}')
    for (var name in paramsMultiple) {
      codez.unshift(paramsMultiple[name].code)
    }

    var extracted = self.getRecursiveCode(params)
    codez = codez.concat(codez, extracted)

    codez.unshift('window.window' + ' = window;')
    for (var global in self.globals) {
      codez.unshift(global + ' = ' + self.globals[global] + ';')
    }

    // Load code
    // self. refers to own function
    // that. refers to locutus
    // this. refers to locutus
    var code = codez.join(';\n')
      .replace(/that\.([a-z_])/g, '$1')
      .replace(/this\.([a-z_])/g, '$1')
      .replace(/window\.setTimeout/g, 'setTimeout')
      .replace(/module\.exports = /g, '')

    self.cli.debug(code)
    eval(code)

    if (!params.func_name) {
      throw new Error('No func_name in ' + JSON.stringify(params))
    }
    if (!params.headKeys) {
      throw new Error('No headKeys in ' + params.func_name)
    }
    if (!params.headKeys.example) {
      throw new Error('No example in ' + params.func_name)
    }

    // Run each example
    for (var i in params.headKeys.example) {
      var test = {
        example: params.headKeys.example[i].join('\n'),
        number: i
      }

      if (!params.headKeys.returns[i] || !params.headKeys.returns[i].length) {
        cb('There is no return for example ' + i, test, params)
        continue
      }

      var testExpected = params.headKeys.returns[i].join('\n')

      // Needs an eval so types are cast properly, also, expected may
      // contain code
      eval('test.expected = ' + testExpected + '')

      // Let's do something evil. Execute line by line (see date.js why)
      // We need test.reslult be the last result of the example code
      for (var j in params.headKeys.example[i]) {
        var testRun = params.headKeys.example[i][j]
        var pat = new RegExp('([a-zA-Z_]+\\.)(' + params.func_name + ')', 'g')

        // Remove category e.g. strings.Contains => Contains
        testRun = testRun.replace(pat, '$2')
        // console.log({pat:pat, testRun:testRun})

        if (+j === params.headKeys.example[i].length - 1) {
          // last action gets saved
          eval('test.result = ' + testRun + '')
        } else {
          eval(testRun + '')
        }
      }

      var jsonExpected = JSON.stringify(test.expected, undefined, 2)
      var jsonResult = JSON.stringify(test.result, undefined, 2)

      // We cannot compare using the JSON.stringify as object order is
      // not guaranteed
      if (!self.equal(test.expected, test.result)) {
        err = 'expected: \n' + jsonExpected + '\n\n' +
              'returned: \n' + jsonResult + '\n'
        cb(err, test, params)
        continue
      }

      cb(null, test, params)
      continue
    }
  })
}

module.exports = LocutusUtil
