---
examples:
  - - "money_format('%i', 1234.56);"
  - - "money_format('%14#8.2n', 1234.5678);"
  - - "money_format('%14#8.2n', -1234.5678);"
  - - "money_format('%(14#8.2n', 1234.5678);"
  - - "money_format('%(14#8.2n', -1234.5678);"
  - - "money_format('%=014#8.2n', 1234.5678);"
  - - "money_format('%=014#8.2n', -1234.5678);"
  - - "money_format('%=*14#8.2n', 1234.5678);"
  - - "money_format('%=*14#8.2n', -1234.5678);"
  - - "money_format('%=*^14#8.2n', 1234.5678);"
  - - "money_format('%=*^14#8.2n', -1234.5678);"
  - - "money_format('%=*!14#8.2n', 1234.5678);"
  - - "money_format('%=*!14#8.2n', -1234.5678);"
  - - "money_format('%i', 3590);"
returns:
  - - "' USD 1,234.56'"
  - - "' $     1,234.57'"
  - - "'-$     1,234.57'"
  - - "' $     1,234.57 '"
  - - "'($     1,234.57)'"
  - - "' $000001,234.57'"
  - - "'-$000001,234.57'"
  - - "' $*****1,234.57'"
  - - "'-$*****1,234.57'"
  - - "'  $****1234.57'"
  - - "' -$****1234.57'"
  - - "' *****1,234.57'"
  - - "'-*****1,234.57'"
  - - "' USD 3,590.00'"
authors:
  original by:
    - 'Brett Zamir (http://brett-zamir.me)'
  bugfixed by:
    - 'Brett Zamir (http://brett-zamir.me)'
  input by:
    - 'daniel airton wermann (http://wermann.com.br)'
notes:
  - - This depends on setlocale having the appropriate
    - "locale (these examples use 'en_US')"
layout: function
function: money_format
category: strings
code: "function money_format (format, number) {\n  //  discuss at: http://phpjs.org/functions/money_format/\n  // original by: Brett Zamir (http://brett-zamir.me)\n  //    input by: daniel airton wermann (http://wermann.com.br)\n  // bugfixed by: Brett Zamir (http://brett-zamir.me)\n  //  depends on: setlocale\n  //        note: This depends on setlocale having the appropriate\n  //        note: locale (these examples use 'en_US')\n  //   example 1: money_format('%i', 1234.56);\n  //   returns 1: ' USD 1,234.56'\n  //   example 2: money_format('%14#8.2n', 1234.5678);\n  //   returns 2: ' $     1,234.57'\n  //   example 3: money_format('%14#8.2n', -1234.5678);\n  //   returns 3: '-$     1,234.57'\n  //   example 4: money_format('%(14#8.2n', 1234.5678);\n  //   returns 4: ' $     1,234.57 '\n  //   example 5: money_format('%(14#8.2n', -1234.5678);\n  //   returns 5: '($     1,234.57)'\n  //   example 6: money_format('%=014#8.2n', 1234.5678);\n  //   returns 6: ' $000001,234.57'\n  //   example 7: money_format('%=014#8.2n', -1234.5678);\n  //   returns 7: '-$000001,234.57'\n  //   example 8: money_format('%=*14#8.2n', 1234.5678);\n  //   returns 8: ' $*****1,234.57'\n  //   example 9: money_format('%=*14#8.2n', -1234.5678);\n  //   returns 9: '-$*****1,234.57'\n  //  example 10: money_format('%=*^14#8.2n', 1234.5678);\n  //  returns 10: '  $****1234.57'\n  //  example 11: money_format('%=*^14#8.2n', -1234.5678);\n  //  returns 11: ' -$****1234.57'\n  //  example 12: money_format('%=*!14#8.2n', 1234.5678);\n  //  returns 12: ' *****1,234.57'\n  //  example 13: money_format('%=*!14#8.2n', -1234.5678);\n  //  returns 13: '-*****1,234.57'\n  //  example 14: money_format('%i', 3590);\n  //  returns 14: ' USD 3,590.00'\n\n  // Per PHP behavior, there seems to be no extra padding for sign when there is a positive number, though my\n  // understanding of the description is that there should be padding; need to revisit examples\n\n  // Helpful info at http://ftp.gnu.org/pub/pub/old-gnu/Manuals/glibc-2.2.3/html_chapter/libc_7.html and http://publib.boulder.ibm.com/infocenter/zos/v1r10/index.jsp?topic=/com.ibm.zos.r10.bpxbd00/strfmp.htm\n\n  if (typeof number !== 'number') {\n    return null\n  }\n  // 1: flags, 3: width, 5: left, 7: right, 8: conversion\n  var regex = /%((=.|[+^(!-])*?)(\\d*?)(#(\\d+))?(\\.(\\d+))?([in%])/g\n\n  // Ensure the locale data we need is set up\n  this.setlocale('LC_ALL', 0)\n  var monetary = this.php_js.locales[this.php_js.localeCategories['LC_MONETARY']]['LC_MONETARY']\n\n  var doReplace = function (n0, flags, n2, width, n4, left, n6, right, conversion) {\n    var value = '',\n      repl = ''\n    if (conversion === '%') {\n      // Percent does not seem to be allowed with intervening content\n      return '%'\n    }\n    var fill = flags && (/=./)\n      .test(flags) ? flags.match(/=(.)/)[1] : ' ' // flag: =f (numeric fill)\n    // flag: ! (suppress currency symbol)\n    var showCurrSymbol = !flags || flags.indexOf('!') === -1\n    // field width: w (minimum field width)\n    width = parseInt(width, 10) || 0\n\n    var neg = number < 0\n    // Convert to string\n    number = number + ''\n    // We don't want negative symbol represented here yet\n    number = neg ? number.slice(1) : number\n\n    var decpos = number.indexOf('.')\n    // Get integer portion\n    var integer = decpos !== -1 ? number.slice(0, decpos) : number\n    // Get decimal portion\n    var fraction = decpos !== -1 ? number.slice(decpos + 1) : ''\n\n    var _str_splice = function (integerStr, idx, thous_sep) {\n      var integerArr = integerStr.split('')\n      integerArr.splice(idx, 0, thous_sep)\n      return integerArr.join('')\n    }\n\n    var init_lgth = integer.length\n    left = parseInt(left, 10)\n    var filler = init_lgth < left\n    if (filler) {\n      var fillnum = left - init_lgth\n      integer = new Array(fillnum + 1)\n        .join(fill) + integer\n    }\n    if (flags.indexOf('^') === -1) {\n      // flag: ^ (disable grouping characters (of locale))\n      // use grouping characters\n      // ','\n      var thous_sep = monetary.mon_thousands_sep\n      // [3] (every 3 digits in U.S.A. locale)\n      var mon_grouping = monetary.mon_grouping\n\n      if (mon_grouping[0] < integer.length) {\n        for (var i = 0, idx = integer.length; i < mon_grouping.length; i++) {\n          // e.g., 3\n          idx -= mon_grouping[i]\n          if (idx <= 0) {\n            break\n          }\n          if (filler && idx < fillnum) {\n            thous_sep = fill\n          }\n          integer = _str_splice(integer, idx, thous_sep)\n        }\n      }\n      if (mon_grouping[i - 1] > 0) {\n        // Repeating last grouping (may only be one) until highest portion of integer reached\n        while (idx > mon_grouping[i - 1]) {\n          idx -= mon_grouping[i - 1]\n          if (filler && idx < fillnum) {\n            thous_sep = fill\n          }\n          integer = _str_splice(integer, idx, thous_sep)\n        }\n      }\n    }\n\n    // left, right\n    if (right === '0') {\n      // No decimal or fractional digits\n      value = integer\n    } else {\n      // '.'\n      var dec_pt = monetary.mon_decimal_point\n      if (right === '' || right === undefined) {\n        right = conversion === 'i' ? monetary.int_frac_digits : monetary.frac_digits\n      }\n      right = parseInt(right, 10)\n\n      if (right === 0) {\n        // Only remove fractional portion if explicitly set to zero digits\n        fraction = ''\n        dec_pt = ''\n      } else if (right < fraction.length) {\n        fraction = Math.round(parseFloat(fraction.slice(0, right) + '.' + fraction.substr(right, 1))) + ''\n        if (right > fraction.length) {\n          fraction = new Array(right - fraction.length + 1)\n            .join('0') + fraction // prepend with 0's\n        }\n      } else if (right > fraction.length) {\n        fraction += new Array(right - fraction.length + 1)\n          .join('0') // pad with 0's\n      }\n      value = integer + dec_pt + fraction\n    }\n\n    var symbol = ''\n    if (showCurrSymbol) {\n      // 'i' vs. 'n' ('USD' vs. '$')\n      symbol = conversion === 'i' ? monetary.int_curr_symbol : monetary.currency_symbol\n    }\n    var sign_posn = neg ? monetary.n_sign_posn : monetary.p_sign_posn\n\n    // 0: no space between curr. symbol and value\n    // 1: space sep. them unless symb. and sign are adjacent then space sep. them from value\n    // 2: space sep. sign and value unless symb. and sign are adjacent then space separates\n    var sep_by_space = neg ? monetary.n_sep_by_space : monetary.p_sep_by_space\n\n    // p_cs_precedes, n_cs_precedes // positive currency symbol follows value = 0; precedes value = 1\n    var cs_precedes = neg ? monetary.n_cs_precedes : monetary.p_cs_precedes\n\n    // Assemble symbol/value/sign and possible space as appropriate\n    if (flags.indexOf('(') !== -1) {\n      // flag: parenth. for negative\n      // Fix: unclear on whether and how sep_by_space, sign_posn, or cs_precedes have\n      // an impact here (as they do below), but assuming for now behaves as sign_posn 0 as\n      // far as localized sep_by_space and sign_posn behavior\n      repl = (cs_precedes ? symbol + (sep_by_space === 1 ? ' ' : '') : '') + value + (!cs_precedes ? (\n        sep_by_space === 1 ? ' ' : '') + symbol : '')\n      if (neg) {\n        repl = '(' + repl + ')'\n      } else {\n        repl = ' ' + repl + ' '\n      }\n    } else {\n      // '+' is default\n      // ''\n      var pos_sign = monetary.positive_sign\n      // '-'\n      var neg_sign = monetary.negative_sign\n      var sign = neg ? (neg_sign) : (pos_sign)\n      var otherSign = neg ? (pos_sign) : (neg_sign)\n      var signPadding = ''\n      if (sign_posn) {\n        // has a sign\n        signPadding = new Array(otherSign.length - sign.length + 1)\n          .join(' ')\n      }\n\n      var valueAndCS = ''\n      switch (sign_posn) {\n        // 0: parentheses surround value and curr. symbol;\n        // 1: sign precedes them;\n        // 2: sign follows them;\n        // 3: sign immed. precedes curr. symbol; (but may be space between)\n        // 4: sign immed. succeeds curr. symbol; (but may be space between)\n        case 0:\n          valueAndCS = cs_precedes ? symbol + (sep_by_space === 1 ? ' ' : '') + value : value + (sep_by_space ===\n          1 ? ' ' : '') + symbol\n          repl = '(' + valueAndCS + ')'\n          break\n        case 1:\n          valueAndCS = cs_precedes ? symbol + (sep_by_space === 1 ? ' ' : '') + value : value + (sep_by_space ===\n          1 ? ' ' : '') + symbol\n          repl = signPadding + sign + (sep_by_space === 2 ? ' ' : '') + valueAndCS\n          break\n        case 2:\n          valueAndCS = cs_precedes ? symbol + (sep_by_space === 1 ? ' ' : '') + value : value + (sep_by_space ===\n          1 ? ' ' : '') + symbol\n          repl = valueAndCS + (sep_by_space === 2 ? ' ' : '') + sign + signPadding\n          break\n        case 3:\n          repl = cs_precedes ? signPadding + sign + (sep_by_space === 2 ? ' ' : '') + symbol + (sep_by_space ===\n          1 ? ' ' : '') + value : value + (sep_by_space === 1 ? ' ' : '') + sign + signPadding + (\n          sep_by_space === 2 ? ' ' : '') + symbol\n          break\n        case 4:\n          repl = cs_precedes ? symbol + (sep_by_space === 2 ? ' ' : '') + signPadding + sign + (sep_by_space ===\n          1 ? ' ' : '') + value : value + (sep_by_space === 1 ? ' ' : '') + symbol + (sep_by_space === 2 ?\n          ' ' : '') + sign + signPadding\n          break\n      }\n    }\n\n    var padding = width - repl.length\n    if (padding > 0) {\n      padding = new Array(padding + 1)\n        .join(' ')\n      // Fix: How does p_sep_by_space affect the count if there is a space? Included in count presumably?\n      if (flags.indexOf('-') !== -1) {\n        // left-justified (pad to right)\n        repl += padding\n      } else {\n        // right-justified (pad to left)\n        repl = padding + repl\n      }\n    }\n    return repl\n  }\n\n  return format.replace(regex, doReplace)\n}\n"
permalink: /functions/money_format/
redirect_from:
  - /functions/strings/money_format/
---

<!-- WARNING! This file is auto generated by `npm run web:inject`, do not edit by hand -->
