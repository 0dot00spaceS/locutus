---
examples:
  - - "sscanf('SN/2350001', 'SN/%d');"
  - - var myVar; // Will be set by function
    - "sscanf('SN/2350001', 'SN/%d', 'myVar');"
  - - "sscanf(\"10--20\", \"%2$d--%1$d\"); // Must escape '$' in PHP, but not JS"
returns:
  - - '[2350001]'
  - - '1'
  - - '[20, 10]'
authors:
  original by:
    - 'Brett Zamir (http://brett-zamir.me)'
notes: []
layout: function
function: sscanf
category: strings
code: "function sscanf (str, format) {\n  //  discuss at: http://phpjs.org/functions/sscanf/\n  // original by: Brett Zamir (http://brett-zamir.me)\n  //        note: Since JS does not support scalar reference variables, any additional arguments to the function will\n  //        note: only be allowable here as strings referring to a global variable (which will then be set to the value\n  //        note: found in 'str' corresponding to the appropriate conversion specification in 'format'\n  //        note: I am unclear on how WS is to be handled here because documentation seems to me to contradict PHP behavior\n  //   example 1: sscanf('SN/2350001', 'SN/%d');\n  //   returns 1: [2350001]\n  //   example 2: var myVar; // Will be set by function\n  //   example 2: sscanf('SN/2350001', 'SN/%d', 'myVar');\n  //   returns 2: 1\n  //   example 3: sscanf(\"10--20\", \"%2$d--%1$d\"); // Must escape '$' in PHP, but not JS\n  //   returns 3: [20, 10]\n\n  // SETUP\n  var retArr = [],\n    num = 0,\n    _NWS = /\\S/,\n    args = arguments,\n    that = this,\n    digit\n\n  var _setExtraConversionSpecs = function (offset) {\n    // Since a mismatched character sets us off track from future legitimate finds, we just scan\n    // to the end for any other conversion specifications (besides a percent literal), setting them to null\n    // sscanf seems to disallow all conversion specification components (of sprintf) except for type specifiers\n    // Do not allow % in last char. class\n    // var matches = format.match(/%[+-]?([ 0]|'.)?-?\\d*(\\.\\d+)?[bcdeufFosxX]/g);\n    var matches = format.slice(offset)\n      .match(/%[cdeEufgosxX]/g) // Do not allow % in last char. class;\n    // b, F,G give errors in PHP, but 'g', though also disallowed, doesn't\n    if (matches) {\n      var lgth = matches.length\n      while (lgth--) {\n        retArr.push(null)\n      }\n    }\n    return _finish()\n  }\n\n  var _finish = function () {\n    if (args.length === 2) {\n      return retArr\n    }\n    for (var i = 0; i < retArr.length; ++i) {\n      that.window[args[i + 2]] = retArr[i]\n    }\n    return i\n  }\n\n  var _addNext = function (j, regex, cb) {\n    if (assign) {\n      var remaining = str.slice(j)\n      var check = width ? remaining.substr(0, width) : remaining\n      var match = regex.exec(check)\n      var testNull = retArr[digit !== undefined ? digit : retArr.length] = match ? (cb ? cb.apply(null, match) :\n        match[0]) : null\n      if (testNull === null) {\n        throw 'No match in string'\n      }\n      return j + match[0].length\n    }\n    return j\n  }\n\n  if (arguments.length < 2) {\n    throw 'Not enough arguments passed to sscanf'\n  }\n\n  // PROCESS\n  for (var i = 0, j = 0; i < format.length; i++) {\n\n    var width = 0,\n      assign = true\n\n    if (format.charAt(i) === '%') {\n      if (format.charAt(i + 1) === '%') {\n        if (str.charAt(j) === '%') {\n          // a matched percent literal\n          // skip beyond duplicated percent\n          ++i, ++j\n          continue\n        }\n        // Format indicated a percent literal, but not actually present\n        return _setExtraConversionSpecs(i + 2)\n      }\n\n      // CHARACTER FOLLOWING PERCENT IS NOT A PERCENT\n\n      // We need 'g' set to get lastIndex\n      var prePattern = new RegExp('^(?:(\\\\d+)\\\\$)?(\\\\*)?(\\\\d*)([hlL]?)', 'g')\n\n      var preConvs = prePattern.exec(format.slice(i + 1))\n\n      var tmpDigit = digit\n      if (tmpDigit && preConvs[1] === undefined) {\n        throw 'All groups in sscanf() must be expressed as numeric if any have already been used'\n      }\n      digit = preConvs[1] ? parseInt(preConvs[1], 10) - 1 : undefined\n\n      assign = !preConvs[2]\n      width = parseInt(preConvs[3], 10)\n      var sizeCode = preConvs[4]\n      i += prePattern.lastIndex\n\n      // Fix: Does PHP do anything with these? Seems not to matter\n      if (sizeCode) {\n        // This would need to be processed later\n        switch (sizeCode) {\n          case 'h':\n          // Treats subsequent as short int (for d,i,n) or unsigned short int (for o,u,x)\n          case 'l':\n          // Treats subsequent as long int (for d,i,n), or unsigned long int (for o,u,x);\n          //    or as double (for e,f,g) instead of float or wchar_t instead of char\n          case 'L':\n          // Treats subsequent as long double (for e,f,g)\n            break\n          default:\n            throw 'Unexpected size specifier in sscanf()!'\n            break\n        }\n      }\n      // PROCESS CHARACTER\n      try {\n        switch (format.charAt(i + 1)) {\n          // For detailed explanations, see http://web.archive.org/web/20031128125047/http://www.uwm.edu/cgi-bin/IMT/wwwman?topic=scanf%283%29&msection=\n          // Also http://www.mathworks.com/access/helpdesk/help/techdoc/ref/sscanf.html\n          // p, S, C arguments in C function not available\n          // DOCUMENTED UNDER SSCANF\n          case 'F':\n          // Not supported in PHP sscanf; the argument is treated as a float, and\n          //  presented as a floating-point number (non-locale aware)\n          // sscanf doesn't support locales, so no need for two (see %f)\n            break\n          case 'g':\n          // Not supported in PHP sscanf; shorter of %e and %f\n          // Irrelevant to input conversion\n            break\n          case 'G':\n          // Not supported in PHP sscanf; shorter of %E and %f\n          // Irrelevant to input conversion\n            break\n          case 'b':\n          // Not supported in PHP sscanf; the argument is treated as an integer, and presented as a binary number\n          // Not supported - couldn't distinguish from other integers\n            break\n          case 'i':\n          // Integer with base detection (Equivalent of 'd', but base 0 instead of 10)\n            j = _addNext(j, /([+-])?(?:(?:0x([\\da-fA-F]+))|(?:0([0-7]+))|(\\d+))/, function (num, sign, hex,\n            oct, dec) {\n              return hex ? parseInt(num, 16) : oct ? parseInt(num, 8) : parseInt(num, 10)\n            })\n            break\n          case 'n':\n          // Number of characters processed so far\n            retArr[digit !== undefined ? digit : retArr.length - 1] = j\n            break\n          // DOCUMENTED UNDER SPRINTF\n          case 'c':\n          // Get character; suppresses skipping over whitespace! (but shouldn't be whitespace in format anyways, so no difference here)\n          // Non-greedy match\n            j = _addNext(j, new RegExp('.{1,' + (width || 1) + '}'))\n            break\n          case 'D':\n          // sscanf documented decimal number; equivalent of 'd';\n          case 'd':\n          // Optionally signed decimal integer\n            j = _addNext(j, /([+-])?(?:0*)(\\d+)/, function (num, sign, dec) {\n            // Ignores initial zeroes, unlike %i and parseInt()\n              var decInt = parseInt((sign || '') + dec, 10)\n              if (decInt < 0) {\n              // PHP also won't allow less than -2147483648\n              // integer overflow with negative\n                return decInt < -2147483648 ? -2147483648 : decInt\n              } else {\n              // PHP also won't allow greater than -2147483647\n                return decInt < 2147483647 ? decInt : 2147483647\n              }\n            })\n            break\n          case 'f':\n          // Although sscanf doesn't support locales, this is used instead of '%F'; seems to be same as %e\n          case 'E':\n          // These don't discriminate here as both allow exponential float of either case\n          case 'e':\n            j = _addNext(j, /([+-])?(?:0*)(\\d*\\.?\\d*(?:[eE]?\\d+)?)/, function (num, sign, dec) {\n              if (dec === '.') {\n                return null\n              }\n            // Ignores initial zeroes, unlike %i and parseFloat()\n              return parseFloat((sign || '') + dec)\n            })\n            break\n          case 'u':\n          // unsigned decimal integer\n          // We won't deal with integer overflows due to signs\n            j = _addNext(j, /([+-])?(?:0*)(\\d+)/, function (num, sign, dec) {\n            // Ignores initial zeroes, unlike %i and parseInt()\n              var decInt = parseInt(dec, 10)\n              if (sign === '-') {\n              // PHP also won't allow greater than 4294967295\n              // integer overflow with negative\n                return 4294967296 - decInt\n              } else {\n                return decInt < 4294967295 ? decInt : 4294967295\n              }\n            })\n            break\n          case 'o':\n          // Octal integer // Fix: add overflows as above?\n            j = _addNext(j, /([+-])?(?:0([0-7]+))/, function (num, sign, oct) {\n              return parseInt(num, 8)\n            })\n            break\n          case 's':\n          // Greedy match\n            j = _addNext(j, /\\S+/)\n            break\n          case 'X':\n          // Same as 'x'?\n          case 'x':\n          // Fix: add overflows as above?\n          // Initial 0x not necessary here\n            j = _addNext(j, /([+-])?(?:(?:0x)?([\\da-fA-F]+))/, function (num, sign, hex) {\n              return parseInt(num, 16)\n            })\n            break\n          case '':\n          // If no character left in expression\n            throw 'Missing character after percent mark in sscanf() format argument'\n          default:\n            throw 'Unrecognized character after percent mark in sscanf() format argument'\n        }\n      } catch (e) {\n        if (e === 'No match in string') {\n          // Allow us to exit\n          return _setExtraConversionSpecs(i + 2)\n        }\n        // Calculate skipping beyond initial percent too\n      }++i\n    } else if (format.charAt(i) !== str.charAt(j)) {\n      // Fix: Double-check i whitespace ignored in string and/or formats\n      _NWS.lastIndex = 0\n      if ((_NWS)\n        .test(str.charAt(j)) || str.charAt(j) === '') {\n        // Whitespace doesn't need to be an exact match)\n        return _setExtraConversionSpecs(i + 1)\n      } else {\n        // Adjust strings when encounter non-matching whitespace, so they align in future checks above\n        // Ok to replace with j++;?\n        str = str.slice(0, j) + str.slice(j + 1)\n        i--\n      }\n    } else {\n      j++\n    }\n  }\n\n  // POST-PROCESSING\n  return _finish()\n}\n"
permalink: /functions/sscanf/
redirect_from:
  - /functions/strings/sscanf/
---

<!-- WARNING! This file is auto generated by `npm run web:inject`, do not edit by hand -->
