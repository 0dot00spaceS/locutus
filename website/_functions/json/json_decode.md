---
examples:
  - - "json_decode('[ 1 ]');"
returns:
  - - '[1]'
authors:
  original by:
    - 'Public Domain (http://www.json.org/json2.js)'
  improved by:
    - T.J. Leahy
    - Michael White
notes: []
layout: function
function: json_decode
category: json
code: "function json_decode (str_json) {\n  //       discuss at: http://phpjs.org/functions/json_decode/\n  //      original by: Public Domain (http://www.json.org/json2.js)\n  // reimplemented by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  //      improved by: T.J. Leahy\n  //      improved by: Michael White\n  //        example 1: json_decode('[ 1 ]');\n  //        returns 1: [1]\n\n  /*\n        http://www.JSON.org/json2.js\n        2008-11-19\n        Public Domain.\n        NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n        See http://www.JSON.org/js.html\n      */\n\n  var json = this.window.JSON\n  if (typeof json === 'object' && typeof json.parse === 'function') {\n    try {\n      return json.parse(str_json)\n    } catch (err) {\n      if (!(err instanceof SyntaxError)) {\n        throw new Error('Unexpected error type in json_decode()')\n      }\n      this.php_js = this.php_js || {}\n      // usable by json_last_error()\n      this.php_js.last_error_json = 4\n      return null\n    }\n  }\n\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g\n  var j\n  var text = str_json\n\n  // Parsing happens in four stages. In the first stage, we replace certain\n  // Unicode characters with escape sequences. JavaScript handles many characters\n  // incorrectly, either silently deleting them, or treating them as line endings.\n  cx.lastIndex = 0\n  if (cx.test(text)) {\n    text = text.replace(cx, function (a) {\n      return '\\\\u' + ('0000' + a.charCodeAt(0)\n          .toString(16))\n        .slice(-4)\n    })\n  }\n\n  // In the second stage, we run the text against regular expressions that look\n  // for non-JSON patterns. We are especially concerned with '()' and 'new'\n  // because they can cause invocation, and '=' because it can cause mutation.\n  // But just to be safe, we want to reject all unexpected forms.\n  // We split the second stage into 4 regexp operations in order to work around\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n  // replace all simple value tokens with ']' characters. Third, we delete all\n  // open brackets that follow a colon or comma or that begin the text. Finally,\n  // we look to see that the remaining characters are only whitespace or ']' or\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n  if ((/^[\\],:{}\\s]*$/)\n    .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n      .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n      .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n    // In the third stage we use the eval function to compile the text into a\n    // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n    // in JavaScript: it can begin a block or an object literal. We wrap the text\n    // in parens to eliminate the ambiguity.\n    j = eval('(' + text + ')')\n\n    return j\n  }\n\n  this.php_js = this.php_js || {}\n  // usable by json_last_error()\n  this.php_js.last_error_json = 4\n  return null\n}\n"
permalink: /functions/json_decode/
redirect_from:
  - /functions/json/json_decode/
---

<!-- WARNING! This file is auto generated by `npm run web:inject`, do not edit by hand -->
