---
examples:
  - - "strtotime('+1 day', 1129633200);"
  - - "strtotime('+1 week 2 days 4 hours 2 seconds', 1129633200);"
  - - "strtotime('last month', 1129633200);"
  - - "strtotime('2009-05-04 08:30:00 GMT');"
  - - "strtotime('2009-05-04 08:30:00+00');"
  - - "strtotime('2009-05-04 08:30:00+02:00');"
  - - "strtotime('2009-05-04T08:30:00Z');"
returns:
  - - '1129719600'
  - - '1130425202'
  - - '1127041200'
  - - '1241425800'
  - - '1241425800'
  - - '1241418600'
  - - '1241425800'
authors:
  original by:
    - 'Caio Ariede (http://caioariede.com)'
  improved by:
    - 'Kevin van Zonneveld (http://kevin.vanzonneveld.net)'
    - 'Caio Ariede (http://caioariede.com)'
    - 'A. Matías Quezada (http://amatiasq.com)'
    - preuter
    - 'Brett Zamir (http://brett-zamir.me)'
    - Mirko Faber
  bugfixed by:
    - Wagner B. Soares
    - Artur Tchernychev
    - 'Stephan Bösch-Plepelits (http://github.com/plepe)'
  input by:
    - David
notes:
  - - Examples all have a fixed timestamp to prevent tests to fail because of variable time(zones)
layout: function
function: strtotime
category: datetime
code: "function strtotime (text, now) {\n  //  discuss at: http://phpjs.org/functions/strtotime/\n  //     version: 1109.2016\n  // original by: Caio Ariede (http://caioariede.com)\n  // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // improved by: Caio Ariede (http://caioariede.com)\n  // improved by: A. Matías Quezada (http://amatiasq.com)\n  // improved by: preuter\n  // improved by: Brett Zamir (http://brett-zamir.me)\n  // improved by: Mirko Faber\n  //    input by: David\n  // bugfixed by: Wagner B. Soares\n  // bugfixed by: Artur Tchernychev\n  // bugfixed by: Stephan Bösch-Plepelits (http://github.com/plepe)\n  //        note: Examples all have a fixed timestamp to prevent tests to fail because of variable time(zones)\n  //   example 1: strtotime('+1 day', 1129633200);\n  //   returns 1: 1129719600\n  //   example 2: strtotime('+1 week 2 days 4 hours 2 seconds', 1129633200);\n  //   returns 2: 1130425202\n  //   example 3: strtotime('last month', 1129633200);\n  //   returns 3: 1127041200\n  //   example 4: strtotime('2009-05-04 08:30:00 GMT');\n  //   returns 4: 1241425800\n  //   example 5: strtotime('2009-05-04 08:30:00+00');\n  //   returns 5: 1241425800\n  //   example 6: strtotime('2009-05-04 08:30:00+02:00');\n  //   returns 6: 1241418600\n  //   example 7: strtotime('2009-05-04T08:30:00Z');\n  //   returns 7: 1241425800\n\n  var parsed, match, today, year, date, days, ranges, len, times, regex, i, fail = false\n\n  if (!text) {\n    return fail\n  }\n\n  // Unecessary spaces\n  text = text.replace(/^\\s+|\\s+$/g, '')\n    .replace(/\\s{2,}/g, ' ')\n    .replace(/[\\t\\r\\n]/g, '')\n    .toLowerCase()\n\n  // in contrast to php, js Date.parse function interprets:\n  // dates given as yyyy-mm-dd as in timezone: UTC,\n  // dates with \".\" or \"-\" as MDY instead of DMY\n  // dates with two-digit years differently\n  // etc...etc...\n  // ...therefore we manually parse lots of common date formats\n  match = text.match(\n    /^(\\d{1,4})([\\-\\.\\/\\:])(\\d{1,2})([\\-\\.\\/\\:])(\\d{1,4})(?:\\s(\\d{1,2}):(\\d{2})?:?(\\d{2})?)?(?:\\s([A-Z]+)?)?$/)\n\n  if (match && match[2] === match[4]) {\n    if (match[1] > 1901) {\n      switch (match[2]) {\n        case '-':\n          {\n          // YYYY-M-D\n            if (match[3] > 12 || match[5] > 31) {\n              return fail\n            }\n\n            return new Date(match[1], parseInt(match[3], 10) - 1, match[5],\n            match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000\n          }\n        case '.':\n          {\n          // YYYY.M.D is not parsed by strtotime()\n            return fail\n          }\n        case '/':\n          {\n          // YYYY/M/D\n            if (match[3] > 12 || match[5] > 31) {\n              return fail\n            }\n\n            return new Date(match[1], parseInt(match[3], 10) - 1, match[5],\n            match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000\n          }\n      }\n    } else if (match[5] > 1901) {\n      switch (match[2]) {\n        case '-':\n          {\n          // D-M-YYYY\n            if (match[3] > 12 || match[1] > 31) {\n              return fail\n            }\n\n            return new Date(match[5], parseInt(match[3], 10) - 1, match[1],\n            match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000\n          }\n        case '.':\n          {\n          // D.M.YYYY\n            if (match[3] > 12 || match[1] > 31) {\n              return fail\n            }\n\n            return new Date(match[5], parseInt(match[3], 10) - 1, match[1],\n            match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000\n          }\n        case '/':\n          {\n          // M/D/YYYY\n            if (match[1] > 12 || match[3] > 31) {\n              return fail\n            }\n\n            return new Date(match[5], parseInt(match[1], 10) - 1, match[3],\n            match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000\n          }\n      }\n    } else {\n      switch (match[2]) {\n        case '-':\n          {\n          // YY-M-D\n            if (match[3] > 12 || match[5] > 31 || (match[1] < 70 && match[1] > 38)) {\n              return fail\n            }\n\n            year = match[1] >= 0 && match[1] <= 38 ? +match[1] + 2000 : match[1]\n            return new Date(year, parseInt(match[3], 10) - 1, match[5],\n            match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000\n          }\n        case '.':\n          {\n          // D.M.YY or H.MM.SS\n            if (match[5] >= 70) {\n            // D.M.YY\n              if (match[3] > 12 || match[1] > 31) {\n                return fail\n              }\n\n              return new Date(match[5], parseInt(match[3], 10) - 1, match[1],\n              match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000\n            }\n            if (match[5] < 60 && !match[6]) {\n            // H.MM.SS\n              if (match[1] > 23 || match[3] > 59) {\n                return fail\n              }\n\n              today = new Date()\n              return new Date(today.getFullYear(), today.getMonth(), today.getDate(),\n              match[1] || 0, match[3] || 0, match[5] || 0, match[9] || 0) / 1000\n            }\n\n          // invalid format, cannot be parsed\n            return fail\n          }\n        case '/':\n          {\n          // M/D/YY\n            if (match[1] > 12 || match[3] > 31 || (match[5] < 70 && match[5] > 38)) {\n              return fail\n            }\n\n            year = match[5] >= 0 && match[5] <= 38 ? +match[5] + 2000 : match[5]\n            return new Date(year, parseInt(match[1], 10) - 1, match[3],\n            match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000\n          }\n        case ':':\n          {\n          // HH:MM:SS\n            if (match[1] > 23 || match[3] > 59 || match[5] > 59) {\n              return fail\n            }\n\n            today = new Date()\n            return new Date(today.getFullYear(), today.getMonth(), today.getDate(),\n            match[1] || 0, match[3] || 0, match[5] || 0) / 1000\n          }\n      }\n    }\n  }\n\n  // other formats and \"now\" should be parsed by Date.parse()\n  if (text === 'now') {\n    return now === null || isNaN(now) ? new Date()\n      .getTime() / 1000 | 0 : now | 0\n  }\n  if (!isNaN(parsed = Date.parse(text))) {\n    return parsed / 1000 | 0\n  }\n  // Browsers != Chrome have problems parsing ISO 8601 date strings, as they do\n  // not accept lower case characters, space, or shortened time zones.\n  // Therefore, fix these problems and try again.\n  // Examples:\n  //   2015-04-15 20:33:59+02\n  //   2015-04-15 20:33:59z\n  //   2015-04-15t20:33:59+02:00\n  if (match = text.match(\n      /^([0-9]{4}-[0-9]{2}-[0-9]{2})[ t]([0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?)([\\+-][0-9]{2}(:[0-9]{2})?|z)/)) {\n    // fix time zone information\n    if (match[4] == 'z') {\n      match[4] = 'Z'\n    } else if (match[4].match(/^([\\+-][0-9]{2})$/)) {\n      match[4] = match[4] + ':00'\n    }\n\n    if (!isNaN(parsed = Date.parse(match[1] + 'T' + match[2] + match[4]))) {\n      return parsed / 1000 | 0\n    }\n  }\n\n  date = now ? new Date(now * 1000) : new Date()\n  days = {\n    'sun': 0,\n    'mon': 1,\n    'tue': 2,\n    'wed': 3,\n    'thu': 4,\n    'fri': 5,\n    'sat': 6\n  }\n  ranges = {\n    'yea': 'FullYear',\n    'mon': 'Month',\n    'day': 'Date',\n    'hou': 'Hours',\n    'min': 'Minutes',\n    'sec': 'Seconds'\n  }\n\n  function lastNext (type, range, modifier) {\n    var diff, day = days[range]\n\n    if (typeof day !== 'undefined') {\n      diff = day - date.getDay()\n\n      if (diff === 0) {\n        diff = 7 * modifier\n      } else if (diff > 0 && type === 'last') {\n        diff -= 7\n      } else if (diff < 0 && type === 'next') {\n        diff += 7\n      }\n\n      date.setDate(date.getDate() + diff)\n    }\n  }\n\n  function process (val) {\n    var splt = val.split(' '), // Todo: Reconcile this with regex using \\s, taking into account browser issues with split and regexes\n      type = splt[0],\n      range = splt[1].substring(0, 3),\n      typeIsNumber = /\\d+/.test(type),\n      ago = splt[2] === 'ago',\n      num = (type === 'last' ? -1 : 1) * (ago ? -1 : 1)\n\n    if (typeIsNumber) {\n      num *= parseInt(type, 10)\n    }\n\n    if (ranges.hasOwnProperty(range) && !splt[1].match(/^mon(day|\\.)?$/i)) {\n      return date['set' + ranges[range]](date['get' + ranges[range]]() + num)\n    }\n\n    if (range === 'wee') {\n      return date.setDate(date.getDate() + (num * 7))\n    }\n\n    if (type === 'next' || type === 'last') {\n      lastNext(type, range, num)\n    } else if (!typeIsNumber) {\n      return false\n    }\n\n    return true\n  }\n\n  times = '(years?|months?|weeks?|days?|hours?|minutes?|min|seconds?|sec' +\n    '|sunday|sun\\\\.?|monday|mon\\\\.?|tuesday|tue\\\\.?|wednesday|wed\\\\.?' +\n    '|thursday|thu\\\\.?|friday|fri\\\\.?|saturday|sat\\\\.?)'\n  regex = '([+-]?\\\\d+\\\\s' + times + '|' + '(last|next)\\\\s' + times + ')(\\\\sago)?'\n\n  match = text.match(new RegExp(regex, 'gi'))\n  if (!match) {\n    return fail\n  }\n\n  for (i = 0, len = match.length; i < len; i++) {\n    if (!process(match[i])) {\n      return fail\n    }\n  }\n\n  // ECMAScript 5 only\n  // if (!match.every(process))\n  //    return false;\n\n  return (date.getTime() / 1000)\n}\n"
permalink: /functions/strtotime/
redirect_from:
  - /functions/datetime/strtotime/
---

<!-- WARNING! This file is auto generated by `npm run web:inject`, do not edit by hand -->
