---
examples:
  - - "strptime('20091112222135', '%Y%m%d%H%M%S'); // Return value will depend on date and locale"
    - "strptime('2009extra', '%Y');"
returns:
  - - "{tm_sec: 35, tm_min: 21, tm_hour: 22, tm_mday: 12, tm_mon: 10, tm_year: 109, tm_wday: 4, tm_yday: 315, unparsed: ''}"
    - "{tm_sec:0, tm_min:0, tm_hour:0, tm_mday:0, tm_mon:0, tm_year:109, tm_wday:3, tm_yday: -1, unparsed: 'extra'}"
authors:
  original by:
    - 'Brett Zamir (http://brett-zamir.me)'
    - strftime
notes: []
layout: function
function: strptime
category: datetime
code: "function strptime (dateStr, format) {\n  //  discuss at: http://phpjs.org/functions/strptime/\n  // original by: Brett Zamir (http://brett-zamir.me)\n  // original by: strftime\n  //  depends on: setlocale\n  //  depends on: array_map\n  //        test: skip\n  //   example 1: strptime('20091112222135', '%Y%m%d%H%M%S'); // Return value will depend on date and locale\n  //   example 1: strptime('2009extra', '%Y');\n  //   returns 1: {tm_sec: 35, tm_min: 21, tm_hour: 22, tm_mday: 12, tm_mon: 10, tm_year: 109, tm_wday: 4, tm_yday: 315, unparsed: ''}\n  //   returns 1: {tm_sec:0, tm_min:0, tm_hour:0, tm_mday:0, tm_mon:0, tm_year:109, tm_wday:3, tm_yday: -1, unparsed: 'extra'}\n\n  // tm_isdst is in other docs; why not PHP?\n\n  // Needs more thorough testing and examples\n\n  var retObj = {\n      tm_sec: 0,\n      tm_min: 0,\n      tm_hour: 0,\n      tm_mday: 0,\n      tm_mon: 0,\n      tm_year: 0,\n      tm_wday: 0,\n      tm_yday: 0,\n      unparsed: ''\n    },\n    i = 0,\n    that = this,\n    amPmOffset = 0,\n    prevHour = false,\n    _reset = function (dateObj, realMday) {\n      // realMday is to allow for a value of 0 in return results (but without\n      // messing up the Date() object)\n      var jan1,\n        o = retObj,\n        d = dateObj\n      o.tm_sec = d.getUTCSeconds()\n      o.tm_min = d.getUTCMinutes()\n      o.tm_hour = d.getUTCHours()\n      o.tm_mday = realMday === 0 ? realMday : d.getUTCDate()\n      o.tm_mon = d.getUTCMonth()\n      o.tm_year = d.getUTCFullYear() - 1900\n      o.tm_wday = realMday === 0 ? (d.getUTCDay() > 0 ? d.getUTCDay() - 1 : 6) : d.getUTCDay()\n      jan1 = new Date(Date.UTC(d.getUTCFullYear(), 0, 1))\n      o.tm_yday = Math.ceil((d - jan1) / (1000 * 60 * 60 * 24))\n    },\n    _date = function () {\n      var o = retObj\n      // We set date to at least 1 to ensure year or month doesn't go backwards\n      return _reset(new Date(Date.UTC(o.tm_year + 1900, o.tm_mon, o.tm_mday || 1, o.tm_hour, o.tm_min, o.tm_sec)),\n        o.tm_mday)\n    }\n\n  // BEGIN STATIC\n  var _NWS = /\\S/,\n    _WS = /\\s/\n\n  var _aggregates = {\n    c: 'locale',\n    D: '%m/%d/%y',\n    F: '%y-%m-%d',\n    r: 'locale',\n    R: '%H:%M',\n    T: '%H:%M:%S',\n    x: 'locale',\n    X: 'locale'\n  }\n\n  /* Fix: Locale alternatives are supported though not documented in PHP; see http://linux.die.net/man/3/strptime\nEc\nEC\nEx\nEX\nEy\nEY\nOd or Oe\nOH\nOI\nOm\nOM\nOS\nOU\nOw\nOW\nOy\n  */\n  var _preg_quote = function (str) {\n    return (str + '')\n      .replace(/([\\\\\\.\\+\\*\\?\\[\\^\\]\\$\\(\\)\\{\\}\\=\\!<>\\|\\:])/g, '\\\\$1')\n  }\n  // END STATIC\n\n  // BEGIN REDUNDANT\n  this.php_js = this.php_js || {}\n  // ensure setup of localization variables takes place\n  this.setlocale('LC_ALL', 0)\n  // END REDUNDANT\n\n  var phpjs = this.php_js\n  var locale = phpjs.localeCategories.LC_TIME\n  var locales = phpjs.locales\n  var lc_time = locales[locale].LC_TIME\n\n  // First replace aggregates (run in a loop because an agg may be made up of other aggs)\n  while (format.match(/%[cDFhnrRtTxX]/)) {\n    format = format.replace(/%([cDFhnrRtTxX])/g, function (m0, m1) {\n      var f = _aggregates[m1]\n      return (f === 'locale' ? lc_time[m1] : f)\n    })\n  }\n\n  var _addNext = function (j, regex, cb) {\n    if (typeof regex === 'string') {\n      regex = new RegExp('^' + regex, 'i')\n    }\n    var check = dateStr.slice(j)\n    var match = regex.exec(check)\n    // Even if the callback returns null after assigning to the return object, the object won't be saved anyways\n    var testNull = match ? cb.apply(null, match) : null\n    if (testNull === null) {\n      throw 'No match in string'\n    }\n    return j + match[0].length\n  }\n\n  var _addLocalized = function (j, formatChar, category) {\n    return _addNext(j, that.array_map(\n        _preg_quote, lc_time[formatChar])\n      .join('|'), // Could make each parenthesized instead and pass index to callback\n\n      function (m) {\n        var match = lc_time[formatChar].search(new RegExp('^' + _preg_quote(m) + '$', 'i'))\n        if (match) {\n          retObj[category] = match[0]\n        }\n      })\n  }\n\n  // BEGIN PROCESSING CHARACTERS\n  for (i = 0, j = 0; i < format.length; i++) {\n    if (format.charAt(i) === '%') {\n      var literalPos = ['%', 'n', 't'].indexOf(format.charAt(i + 1))\n      if (literalPos !== -1) {\n        if (['%', '\\n', '\\t'].indexOf(dateStr.charAt(j)) === literalPos) {\n          // a matched literal\n          ++i;\n          // skip beyond\n          ++j\n          continue\n        }\n        // Format indicated a percent literal, but not actually present\n        return false\n      }\n      var formatChar = format.charAt(i + 1)\n      try {\n        switch (formatChar) {\n          case 'a':\n          // Fall-through // Sun-Sat\n          case 'A':\n          // Sunday-Saturday\n          // Changes nothing else\n            j = _addLocalized(j, formatChar, 'tm_wday')\n            break\n          case 'h':\n          // Fall-through (alias of 'b');\n          case 'b':\n          // Jan-Dec\n            j = _addLocalized(j, 'b', 'tm_mon')\n          // Also changes wday, yday\n            _date()\n            break\n          case 'B':\n          // January-December\n            j = _addLocalized(j, formatChar, 'tm_mon')\n          // Also changes wday, yday\n            _date()\n            break\n          case 'C':\n          // 0+; century (19 for 20th)\n            j = _addNext(j, /^\\d?\\d/, // PHP docs say two-digit, but accepts one-digit (two-digit max)\n\n            function (d) {\n              var year = (parseInt(d, 10) - 19) * 100\n              retObj.tm_year = year\n              _date()\n              if (!retObj.tm_yday) {\n                retObj.tm_yday = -1\n              }\n              // Also changes wday; and sets yday to -1 (always?)\n            })\n            break\n          case 'd':\n          // Fall-through  01-31 day\n          case 'e':\n          // 1-31 day\n            j = _addNext(j, formatChar === 'd' ? /^(0[1-9]|[1-2]\\d|3[0-1])/ : /^([1-2]\\d|3[0-1]|[1-9])/,\n            function (d) {\n              var dayMonth = parseInt(d, 10)\n              retObj.tm_mday = dayMonth\n              // Also changes w_day, y_day\n              _date()\n            })\n            break\n          case 'g':\n          // No apparent effect; 2-digit year (see 'V')\n            break\n          case 'G':\n          // No apparent effect; 4-digit year (see 'V')'\n            break\n          case 'H':\n          // 00-23 hours\n            j = _addNext(j, /^([0-1]\\d|2[0-3])/, function (d) {\n              var hour = parseInt(d, 10)\n              retObj.tm_hour = hour\n            // Changes nothing else\n            })\n            break\n          case 'l':\n          // Fall-through of lower-case 'L'; 1-12 hours\n          case 'I':\n          // 01-12 hours\n            j = _addNext(j, formatChar === 'l' ? /^([1-9]|1[0-2])/ : /^(0[1-9]|1[0-2])/, function (d) {\n              var hour = parseInt(d, 10) - 1 + amPmOffset\n              retObj.tm_hour = hour\n            // Used for coordinating with am-pm\n              prevHour = true\n            // Changes nothing else, but affected by prior 'p/P'\n            })\n            break\n          case 'j':\n          // 001-366 day of year\n            j = _addNext(j, /^(00[1-9]|0[1-9]\\d|[1-2]\\d\\d|3[0-6][0-6])/, function (d) {\n              var dayYear = parseInt(d, 10) - 1\n              retObj.tm_yday = dayYear\n            // Changes nothing else (oddly, since if original by a given year, could calculate other fields)\n            })\n            break\n          case 'm':\n          // 01-12 month\n            j = _addNext(j, /^(0[1-9]|1[0-2])/, function (d) {\n              var month = parseInt(d, 10) - 1\n              retObj.tm_mon = month\n            // Also sets wday and yday\n              _date()\n            })\n            break\n          case 'M':\n          // 00-59 minutes\n            j = _addNext(j, /^[0-5]\\d/, function (d) {\n              var minute = parseInt(d, 10)\n              retObj.tm_min = minute\n            // Changes nothing else\n            })\n            break\n          case 'P':\n          // Seems not to work; AM-PM\n          // Could make fall-through instead since supposed to be a synonym despite PHP docs\n            return false\n          case 'p':\n          // am-pm\n            j = _addNext(j, /^(am|pm)/i, function (d) {\n            // No effect on 'H' since already 24 hours but\n            //   works before or after setting of l/I hour\n              amPmOffset = (/a/)\n              .test(d) ? 0 : 12\n              if (prevHour) {\n                retObj.tm_hour += amPmOffset\n              }\n            })\n            break\n          case 's':\n          // Unix timestamp (in seconds)\n            j = _addNext(j, /^\\d+/, function (d) {\n              var timestamp = parseInt(d, 10)\n              var date = new Date(Date.UTC(timestamp * 1000))\n              _reset(date)\n            // Affects all fields, but can't be negative (and initial + not allowed)\n            })\n            break\n          case 'S':\n          // 00-59 seconds\n            j = _addNext(j, /^[0-5]\\d/, // strptime also accepts 60-61 for some reason\n\n            function (d) {\n              var second = parseInt(d, 10)\n              retObj.tm_sec = second\n              // Changes nothing else\n            })\n            break\n          case 'u':\n          // Fall-through; 1 (Monday)-7(Sunday)\n          case 'w':\n          // 0 (Sunday)-6(Saturday)\n            j = _addNext(j, /^\\d/, function (d) {\n              retObj.tm_wday = d - (formatChar === 'u')\n            // Changes nothing else apparently\n            })\n            break\n          case 'U':\n          // Fall-through (week of year, from 1st Sunday)\n          case 'V':\n          // Fall-through (ISO-8601:1988 week number; from first 4-weekday week, starting with Monday)\n          case 'W':\n          // Apparently ignored (week of year, from 1st Monday)\n            break\n          case 'y':\n          // 69 (or higher) for 1969+, 68 (or lower) for 2068-\n            j = _addNext(j, /^\\d?\\d/, // PHP docs say two-digit, but accepts one-digit (two-digit max)\n\n            function (d) {\n              d = parseInt(d, 10)\n              var year = d >= 69 ? d : d + 100\n              retObj.tm_year = year\n              _date()\n              if (!retObj.tm_yday) {\n                retObj.tm_yday = -1\n              }\n              // Also changes wday; and sets yday to -1 (always?)\n            })\n            break\n          case 'Y':\n          // 2010 (4-digit year)\n            j = _addNext(j, /^\\d{1,4}/, // PHP docs say four-digit, but accepts one-digit (four-digit max)\n\n            function (d) {\n              var year = (parseInt(d, 10)) - 1900\n              retObj.tm_year = year\n              _date()\n              if (!retObj.tm_yday) {\n                retObj.tm_yday = -1\n              }\n              // Also changes wday; and sets yday to -1 (always?)\n            })\n            break\n          case 'z':\n          // Timezone; on my system, strftime gives -0800, but strptime seems not to alter hour setting\n            break\n          case 'Z':\n          // Timezone; on my system, strftime gives PST, but strptime treats text as unparsed\n            break\n          default:\n            throw 'Unrecognized formatting character in strptime()'\n        }\n      } catch (e) {\n        if (e === 'No match in string') {\n          // Allow us to exit\n          // There was supposed to be a matching format but there wasn't\n          return false\n        }\n        // Calculate skipping beyond initial percent too\n      }++i\n    } else if (format.charAt(i) !== dateStr.charAt(j)) {\n      // If extra whitespace at beginning or end of either, or between formats, no problem\n      // (just a problem when between % and format specifier)\n\n      // If the string has white-space, it is ok to ignore\n      if (dateStr.charAt(j)\n        .search(_WS) !== -1) {\n        j++\n        // Let the next iteration try again with the same format character\n        i--\n      } else if (format.charAt(i)\n        .search(_NWS) !== -1) {\n        // Any extra formatting characters besides white-space causes\n        // problems (do check after WS though, as may just be WS in string before next character)\n        return false\n      }\n      // Extra WS in format\n      // Adjust strings when encounter non-matching whitespace, so they align in future checks above\n      // Will check on next iteration (against same (non-WS) string character)\n    } else {\n      j++\n    }\n  }\n\n  // POST-PROCESSING\n  // Will also get extra whitespace; empty string if none\n  retObj.unparsed = dateStr.slice(j)\n  return retObj\n}\n"
permalink: /functions/strptime/
redirect_from:
  - /functions/datetime/strptime/
---

<!-- WARNING! This file is auto generated by `npm run web:inject`, do not edit by hand -->
