---
examples:
  - - "xdiff_string_diff('', 'Hello world!');"
returns:
  - - "'@@ -0,0 +1,1 @@\\n+Hello world!'"
authors:
  original by:
    - 'Brett Zamir (http://brett-zamir.me)'
  improved by:
    - 'Brett Zamir (http://brett-zamir.me)'
  bugfixed by:
    - 'Imgen Tata (http://www.myipdf.com/)'
notes:
  - - The minimal argument is not currently supported
layout: function
function: xdiff_string_diff
category: xdiff
code: "function xdiff_string_diff (old_data, new_data, context_lines, minimal) {\n  //  discuss at: http://phpjs.org/functions/xdiff_string_diff\n  // original by: Brett Zamir (http://brett-zamir.me)\n  //    based on: Imgen Tata (http://www.myipdf.com/)\n  // bugfixed by: Imgen Tata (http://www.myipdf.com/)\n  // improved by: Brett Zamir (http://brett-zamir.me)\n  //        note: The minimal argument is not currently supported\n  //   example 1: xdiff_string_diff('', 'Hello world!');\n  //   returns 1: '@@ -0,0 +1,1 @@\\n+Hello world!'\n\n  // (This code was done by Imgen Tata; I have only reformatted for use in php.js)\n\n  // See http://en.wikipedia.org/wiki/Diff#Unified_format\n  var i = 0,\n    j = 0,\n    k = 0,\n    ori_hunk_start, new_hunk_start, ori_hunk_end, new_hunk_end, ori_hunk_line_no, new_hunk_line_no, ori_hunk_size,\n    new_hunk_size,\n    // Potential configuration\n    MAX_CONTEXT_LINES = Number.POSITIVE_INFINITY,\n    MIN_CONTEXT_LINES = 0,\n    DEFAULT_CONTEXT_LINES = 3,\n    //\n    HEADER_PREFIX = '@@ ',\n    HEADER_SUFFIX = ' @@',\n    ORIGINAL_INDICATOR = '-',\n    NEW_INDICATOR = '+',\n    RANGE_SEPARATOR = ',',\n    CONTEXT_INDICATOR = ' ',\n    DELETION_INDICATOR = '-',\n    ADDITION_INDICATOR = '+',\n    ori_lines, new_lines, NEW_LINE = '\\n',\n    /**\n     * Trims string\n     */\n    trim = function (text) {\n      if (typeof text !== 'string') {\n        throw new Error('String parameter required')\n      }\n\n      return text.replace(/(^\\s*)|(\\s*$)/g, '')\n    },\n    /**\n     * Verifies type of arguments\n     */\n    verify_type = function (type) {\n      var args = arguments,\n        args_len = arguments.length,\n        basic_types = ['number', 'boolean', 'string', 'function', 'object', 'undefined'],\n        basic_type, i, j, type_of_type = typeof type\n      if (type_of_type !== 'string' && type_of_type !== 'function') {\n        throw new Error('Bad type parameter')\n      }\n\n      if (args_len < 2) {\n        throw new Error('Too few arguments')\n      }\n\n      if (type_of_type === 'string') {\n        type = trim(type)\n\n        if (type === '') {\n          throw new Error('Bad type parameter')\n        }\n\n        for (j = 0; j < basic_types.length; j++) {\n          basic_type = basic_types[j]\n\n          if (basic_type == type) {\n            for (i = 1; i < args_len; i++) {\n              if (typeof args[i] !== type) {\n                throw new Error('Bad type')\n              }\n            }\n\n            return\n          }\n        }\n\n        throw new Error('Bad type parameter')\n      }\n\n      // Not basic type. we need to use instanceof operator\n      for (i = 1; i < args_len; i++) {\n        if (!(args[i] instanceof type)) {\n          throw new Error('Bad type')\n        }\n      }\n    },\n    /**\n     * Checks if the specified array contains an element with specified value\n     */\n    has_value = function (array, value) {\n      var i\n      verify_type(Array, array)\n\n      for (i = 0; i < array.length; i++) {\n        if (array[i] === value) {\n          return true\n        }\n      }\n\n      return false\n    },\n    /**\n     * Checks the type of arguments\n     * @param {String | Function} type Specifies the desired type\n     * @return {Boolean} Return true if all arguments after the type argument are of specified type. Else false\n     */\n    are_type_of = function (type) {\n      var args = arguments,\n        args_len = arguments.length,\n        basic_types = ['number', 'boolean', 'string', 'function', 'object', 'undefined'],\n        basic_type, i, j, type_of_type = typeof type\n      if (type_of_type !== 'string' && type_of_type !== 'function') {\n        throw new Error('Bad type parameter')\n      }\n\n      if (args_len < 2) {\n        throw new Error('Too few arguments')\n      }\n\n      if (type_of_type === 'string') {\n        type = trim(type)\n\n        if (type === '') {\n          return false\n        }\n\n        for (j = 0; j < basic_types.length; j++) {\n          basic_type = basic_types[j]\n\n          if (basic_type == type) {\n            for (i = 1; i < args_len; i++) {\n              if (typeof args[i] != type) {\n                return false\n              }\n            }\n\n            return true\n          }\n        }\n\n        throw new Error('Bad type parameter')\n      }\n\n      // Not basic type. we need to use instanceof operator\n      for (i = 1; i < args_len; i++) {\n        if (!(args[i] instanceof type)) {\n          return false\n        }\n      }\n\n      return true\n    },\n    /*\n     * Initialize and return an array with specified size and initial value\n     */\n    get_initialized_array = function (array_size, init_value) {\n      var array = [],\n        i\n      verify_type('number', array_size)\n\n      for (i = 0; i < array_size; i++) {\n        array.push(init_value)\n      }\n\n      return array\n    },\n    /**\n     * Splits text into lines and return as a string array\n     */\n    split_into_lines = function (text) {\n      verify_type('string', text)\n\n      if (text === '') {\n        return []\n      }\n      return text.split('\\n')\n    },\n    is_empty_array = function (obj) {\n      return are_type_of(Array, obj) && obj.length === 0\n    },\n    /**\n     * Finds longest common sequence between two sequences\n     * @see {@link http://wordaligned.org/articles/longest-common-subsequence}\n     */\n    find_longest_common_sequence = function (seq1, seq2, seq1_is_in_lcs, seq2_is_in_lcs) {\n      if (!are_type_of(Array, seq1, seq2)) {\n        throw new Error('Array parameters are required')\n      }\n\n      // Deal with edge case\n      if (is_empty_array(seq1) || is_empty_array(seq2)) {\n        return []\n      }\n\n      // Function to calculate lcs lengths\n      var lcs_lens = function (xs, ys) {\n          var i, j, prev,\n            curr = get_initialized_array(ys.length + 1, 0)\n\n          for (i = 0; i < xs.length; i++) {\n            prev = curr.slice(0)\n            for (j = 0; j < ys.length; j++) {\n              if (xs[i] === ys[j]) {\n                curr[j + 1] = prev[j] + 1\n              } else {\n                curr[j + 1] = Math.max(curr[j], prev[j + 1])\n              }\n            }\n          }\n\n          return curr\n        },\n        // Function to find lcs and fill in the array to indicate the optimal longest common sequence\n        find_lcs = function (xs, xidx, xs_is_in, ys) {\n          var i, xb, xe, ll_b, ll_e, pivot, max, yb, ye,\n            nx = xs.length,\n            ny = ys.length\n\n          if (nx === 0) {\n            return []\n          }\n          if (nx === 1) {\n            if (has_value(ys, xs[0])) {\n              xs_is_in[xidx] = true\n              return [xs[0]]\n            }\n            return []\n          }\n          i = Math.floor(nx / 2)\n          xb = xs.slice(0, i)\n          xe = xs.slice(i)\n          ll_b = lcs_lens(xb, ys)\n          ll_e = lcs_lens(xe.slice(0)\n            .reverse(), ys.slice(0)\n            .reverse())\n\n          pivot = 0\n          max = 0\n          for (j = 0; j <= ny; j++) {\n            if (ll_b[j] + ll_e[ny - j] > max) {\n              pivot = j\n              max = ll_b[j] + ll_e[ny - j]\n            }\n          }\n          yb = ys.slice(0, pivot)\n          ye = ys.slice(pivot)\n          return find_lcs(xb, xidx, xs_is_in, yb)\n            .concat(find_lcs(xe, xidx + i, xs_is_in, ye))\n        }\n\n      // Fill in seq1_is_in_lcs to find the optimal longest common subsequence of first sequence\n      find_lcs(seq1, 0, seq1_is_in_lcs, seq2)\n      // Fill in seq2_is_in_lcs to find the optimal longest common subsequence of second sequence and return the result\n      return find_lcs(seq2, 0, seq2_is_in_lcs, seq1)\n    }\n\n  // First, check the parameters\n  if (are_type_of('string', old_data, new_data) === false) {\n    return false\n  }\n\n  if (old_data == new_data) {\n    return ''\n  }\n\n  if (typeof context_lines !== 'number' || context_lines > MAX_CONTEXT_LINES || context_lines < MIN_CONTEXT_LINES) {\n    context_lines = DEFAULT_CONTEXT_LINES\n  }\n\n  ori_lines = split_into_lines(old_data)\n  new_lines = split_into_lines(new_data)\n  var ori_len = ori_lines.length,\n    new_len = new_lines.length,\n    ori_is_in_lcs = get_initialized_array(ori_len, false),\n    new_is_in_lcs = get_initialized_array(new_len, false),\n    lcs_len = find_longest_common_sequence(ori_lines, new_lines, ori_is_in_lcs, new_is_in_lcs)\n    .length,\n    unidiff = ''\n\n  if (lcs_len === 0) {\n    // No common sequence\n    unidiff = HEADER_PREFIX + ORIGINAL_INDICATOR + (ori_len > 0 ? '1' : '0') + RANGE_SEPARATOR + ori_len + ' ' +\n      NEW_INDICATOR + (new_len > 0 ? '1' : '0') + RANGE_SEPARATOR + new_len + HEADER_SUFFIX\n\n    for (i = 0; i < ori_len; i++) {\n      unidiff += NEW_LINE + DELETION_INDICATOR + ori_lines[i]\n    }\n\n    for (j = 0; j < new_len; j++) {\n      unidiff += NEW_LINE + ADDITION_INDICATOR + new_lines[j]\n    }\n\n    return unidiff\n  }\n\n  var leading_context = [],\n    trailing_context = [],\n    actual_leading_context = [],\n    actual_trailing_context = [],\n\n    // Regularize leading context by the context_lines parameter\n    regularize_leading_context = function (context) {\n      if (context.length === 0 || context_lines === 0) {\n        return []\n      }\n\n      var context_start_pos = Math.max(context.length - context_lines, 0)\n\n      return context.slice(context_start_pos)\n    },\n\n    // Regularize trailing context by the context_lines parameter\n    regularize_trailing_context = function (context) {\n      if (context.length === 0 || context_lines === 0) {\n        return []\n      }\n\n      return context.slice(0, Math.min(context_lines, context.length))\n    }\n\n  // Skip common lines in the beginning\n  while (i < ori_len && ori_is_in_lcs[i] === true && new_is_in_lcs[i] === true) {\n    leading_context.push(ori_lines[i])\n    i++\n  }\n\n  j = i\n  // The index in the longest common sequence\n  k = i\n  ori_hunk_start = i\n  new_hunk_start = j\n  ori_hunk_end = i\n  new_hunk_end = j\n\n  while (i < ori_len || j < new_len) {\n    while (i < ori_len && ori_is_in_lcs[i] === false) {\n      i++\n    }\n    ori_hunk_end = i\n\n    while (j < new_len && new_is_in_lcs[j] === false) {\n      j++\n    }\n    new_hunk_end = j\n\n    // Find the trailing context\n    trailing_context = []\n    while (i < ori_len && ori_is_in_lcs[i] === true && j < new_len && new_is_in_lcs[j] === true) {\n      trailing_context.push(ori_lines[i])\n      k++\n      i++\n      j++\n    }\n\n    if (k >= lcs_len || // No more in longest common lines\n      trailing_context.length >= 2 * context_lines) {\n      // Context break found\n      if (trailing_context.length < 2 * context_lines) {\n        // It must be last block of common lines but not a context break\n        trailing_context = []\n\n        // Force break out\n        i = ori_len\n        j = new_len\n\n        // Update hunk ends to force output to the end\n        ori_hunk_end = ori_len\n        new_hunk_end = new_len\n      }\n\n      // Output the diff hunk\n\n      // Trim the leading and trailing context block\n      actual_leading_context = regularize_leading_context(leading_context)\n      actual_trailing_context = regularize_trailing_context(trailing_context)\n\n      ori_hunk_start -= actual_leading_context.length\n      new_hunk_start -= actual_leading_context.length\n      ori_hunk_end += actual_trailing_context.length\n      new_hunk_end += actual_trailing_context.length\n\n      ori_hunk_line_no = ori_hunk_start + 1\n      new_hunk_line_no = new_hunk_start + 1\n      ori_hunk_size = ori_hunk_end - ori_hunk_start\n      new_hunk_size = new_hunk_end - new_hunk_start\n\n      // Build header\n      unidiff += HEADER_PREFIX + ORIGINAL_INDICATOR + ori_hunk_line_no + RANGE_SEPARATOR + ori_hunk_size + ' ' +\n        NEW_INDICATOR + new_hunk_line_no + RANGE_SEPARATOR + new_hunk_size + HEADER_SUFFIX + NEW_LINE\n\n      // Build the diff hunk content\n      while (ori_hunk_start < ori_hunk_end || new_hunk_start < new_hunk_end) {\n        if (ori_hunk_start < ori_hunk_end && ori_is_in_lcs[ori_hunk_start] === true && new_is_in_lcs[\n            new_hunk_start] === true) {\n          // The context line\n          unidiff += CONTEXT_INDICATOR + ori_lines[ori_hunk_start] + NEW_LINE\n          ori_hunk_start++\n          new_hunk_start++\n        } else if (ori_hunk_start < ori_hunk_end && ori_is_in_lcs[ori_hunk_start] === false) {\n          // The deletion line\n          unidiff += DELETION_INDICATOR + ori_lines[ori_hunk_start] + NEW_LINE\n          ori_hunk_start++\n        } else if (new_hunk_start < new_hunk_end && new_is_in_lcs[new_hunk_start] === false) {\n          // The additional line\n          unidiff += ADDITION_INDICATOR + new_lines[new_hunk_start] + NEW_LINE\n          new_hunk_start++\n        }\n      }\n\n      // Update hunk position and leading context\n      ori_hunk_start = i\n      new_hunk_start = j\n      leading_context = trailing_context\n    }\n  }\n\n  // Trim the trailing new line if it exists\n  if (unidiff.length > 0 && unidiff.charAt(unidiff.length) === NEW_LINE) {\n    unidiff = unidiff.slice(0, -1)\n  }\n\n  return unidiff\n}\n"
permalink: /functions/xdiff_string_diff/
redirect_from:
  - /functions/xdiff/xdiff_string_diff/
---

<!-- WARNING! This file is auto generated by `npm run web:inject`, do not edit by hand -->
