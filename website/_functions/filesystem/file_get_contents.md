---
examples:
  - - "var buf file_get_contents('http://google.com');"
    - "buf.indexOf('Google') !== -1"
returns:
  - - 'true'
authors:
  original by:
    - Legaev Andrey
  improved by:
    - 'Kevin van Zonneveld (http://kevin.vanzonneveld.net)'
    - 'Brett Zamir (http://brett-zamir.me)'
  bugfixed by:
    - 'Brett Zamir (http://brett-zamir.me)'
  input by:
    - Jani Hartikainen
    - Raphael (Ao) RUDLER
notes:
  - - This function uses XmlHttpRequest and cannot retrieve resource from different domain without modifications.
    - Synchronous by default (as in PHP) so may lock up browser. Can
    - 'get async by setting a custom "phpjs.async" property to true and "notification" for an'
    - 'optional callback (both as context params, with responseText, and other JS-specific'
    - "request properties available via 'this'). Note that file_get_contents() will not return the text"
    - 'in such a case (use this.responseText within the callback). Or, consider using'
    - "jQuery's: $('#divId').load('http://url') instead."
    - 'The context argument is only implemented for http, and only partially (see below for'
    - '"Presently unimplemented HTTP context options"); also the arguments passed to'
    - notification are incomplete
layout: function
function: file_get_contents
category: filesystem
code: "function file_get_contents (url, flags, context, offset, maxLen) {\n  //  discuss at: http://phpjs.org/functions/file_get_contents/\n  // original by: Legaev Andrey\n  //    input by: Jani Hartikainen\n  //    input by: Raphael (Ao) RUDLER\n  // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // improved by: Brett Zamir (http://brett-zamir.me)\n  // bugfixed by: Brett Zamir (http://brett-zamir.me)\n  //        note: This function uses XmlHttpRequest and cannot retrieve resource from different domain without modifications.\n  //        note: Synchronous by default (as in PHP) so may lock up browser. Can\n  //        note: get async by setting a custom \"phpjs.async\" property to true and \"notification\" for an\n  //        note: optional callback (both as context params, with responseText, and other JS-specific\n  //        note: request properties available via 'this'). Note that file_get_contents() will not return the text\n  //        note: in such a case (use this.responseText within the callback). Or, consider using\n  //        note: jQuery's: $('#divId').load('http://url') instead.\n  //        note: The context argument is only implemented for http, and only partially (see below for\n  //        note: \"Presently unimplemented HTTP context options\"); also the arguments passed to\n  //        note: notification are incomplete\n  //        test: skip\n  //   example 1: var buf file_get_contents('http://google.com');\n  //   example 1: buf.indexOf('Google') !== -1\n  //   returns 1: true\n\n  var tmp, headers = [],\n    newTmp = [],\n    k = 0,\n    i = 0,\n    href = '',\n    pathPos = -1,\n    flagNames = 0,\n    content = null,\n    http_stream = false\n  var func = function (value) {\n    return value.substring(1) !== ''\n  }\n\n  // BEGIN REDUNDANT\n  this.php_js = this.php_js || {}\n  this.php_js.ini = this.php_js.ini || {}\n  // END REDUNDANT\n  var ini = this.php_js.ini\n  context = context || this.php_js.default_streams_context || null\n\n  if (!flags) {\n    flags = 0\n  }\n  var OPTS = {\n    FILE_USE_INCLUDE_PATH: 1,\n    FILE_TEXT: 32,\n    FILE_BINARY: 64\n  }\n  if (typeof flags === 'number') {\n    // Allow for a single string or an array of string flags\n    flagNames = flags\n  } else {\n    flags = [].concat(flags)\n    for (i = 0; i < flags.length; i++) {\n      if (OPTS[flags[i]]) {\n        flagNames = flagNames | OPTS[flags[i]]\n      }\n    }\n  }\n\n  if (flagNames & OPTS.FILE_BINARY && (flagNames & OPTS.FILE_TEXT)) {\n    // These flags shouldn't be together\n    throw 'You cannot pass both FILE_BINARY and FILE_TEXT to file_get_contents()'\n  }\n\n  if ((flagNames & OPTS.FILE_USE_INCLUDE_PATH) && ini.include_path && ini.include_path.local_value) {\n    var slash = ini.include_path.local_value.indexOf('/') !== -1 ? '/' : '\\\\'\n    url = ini.include_path.local_value + slash + url\n  } else if (!/^(https?|file):/.test(url)) {\n    // Allow references within or below the same directory (should fix to allow other relative references or root reference; could make dependent on parse_url())\n    href = this.window.location.href\n    pathPos = url.indexOf('/') === 0 ? href.indexOf('/', 8) - 1 : href.lastIndexOf('/')\n    url = href.slice(0, pathPos + 1) + url\n  }\n\n  var http_options\n  if (context) {\n    http_options = context.stream_options && context.stream_options.http\n    http_stream = !!http_options\n  }\n\n  if (!context || !context.stream_options || http_stream) {\n    var req = this.window.ActiveXObject ? new ActiveXObject('Microsoft.XMLHTTP') : new XMLHttpRequest()\n    if (!req) {\n      throw new Error('XMLHttpRequest not supported')\n    }\n\n    var method = http_stream ? http_options.method : 'GET'\n    var async = !!(context && context.stream_params && context.stream_params['phpjs.async'])\n\n    if (ini['phpjs.ajaxBypassCache'] && ini['phpjs.ajaxBypassCache'].local_value) {\n      url += (url.match(/\\?/) == null ? '?' : '&') + (new Date())\n        .getTime() // Give optional means of forcing bypass of cache\n    }\n\n    req.open(method, url, async)\n    if (async) {\n      var notification = context.stream_params.notification\n      if (typeof notification === 'function') {\n        // Fix: make work with req.addEventListener if available: https://developer.mozilla.org/En/Using_XMLHttpRequest\n        if (0 && req.addEventListener) {\n          // Unimplemented so don't allow to get here\n          /*\n          req.addEventListener('progress', updateProgress, false);\n          req.addEventListener('load', transferComplete, false);\n          req.addEventListener('error', transferFailed, false);\n          req.addEventListener('abort', transferCanceled, false);\n          */\n        } else {\n          req.onreadystatechange = function (aEvt) {\n            // aEvt has stopPropagation(), preventDefault(); see https://developer.mozilla.org/en/NsIDOMEvent\n            // Other XMLHttpRequest properties: multipart, responseXML, status, statusText, upload, withCredentials\n            /*\n  PHP Constants:\n  STREAM_NOTIFY_RESOLVE   1       A remote address required for this stream has been resolved, or the resolution failed. See severity  for an indication of which happened.\n  STREAM_NOTIFY_CONNECT   2     A connection with an external resource has been established.\n  STREAM_NOTIFY_AUTH_REQUIRED 3     Additional authorization is required to access the specified resource. Typical issued with severity level of STREAM_NOTIFY_SEVERITY_ERR.\n  STREAM_NOTIFY_MIME_TYPE_IS  4     The mime-type of resource has been identified, refer to message for a description of the discovered type.\n  STREAM_NOTIFY_FILE_SIZE_IS  5     The size of the resource has been discovered.\n  STREAM_NOTIFY_REDIRECTED    6     The external resource has redirected the stream to an alternate location. Refer to message .\n  STREAM_NOTIFY_PROGRESS  7     Indicates current progress of the stream transfer in bytes_transferred and possibly bytes_max as well.\n  STREAM_NOTIFY_COMPLETED 8     There is no more data available on the stream.\n  STREAM_NOTIFY_FAILURE   9     A generic error occurred on the stream, consult message and message_code for details.\n  STREAM_NOTIFY_AUTH_RESULT   10     Authorization has been completed (with or without success).\n\n  STREAM_NOTIFY_SEVERITY_INFO 0     Normal, non-error related, notification.\n  STREAM_NOTIFY_SEVERITY_WARN 1     Non critical error condition. Processing may continue.\n  STREAM_NOTIFY_SEVERITY_ERR  2     A critical error occurred. Processing cannot continue.\n  */\n            var objContext = {\n              responseText: req.responseText,\n              responseXML: req.responseXML,\n              status: req.status,\n              statusText: req.statusText,\n              readyState: req.readyState,\n              evt: aEvt\n            } // properties are not available in PHP, but offered on notification via 'this' for convenience\n            // notification args: notification_code, severity, message, message_code, bytes_transferred, bytes_max (all int's except string 'message')\n            // Need to add message, etc.\n            var bytes_transferred\n            switch (req.readyState) {\n              case 0:\n              //     UNINITIALIZED     open() has not been called yet.\n                notification.call(objContext, 0, 0, '', 0, 0, 0)\n                break\n              case 1:\n              //     LOADING     send() has not been called yet.\n                notification.call(objContext, 0, 0, '', 0, 0, 0)\n                break\n              case 2:\n              //     LOADED     send() has been called, and headers and status are available.\n                notification.call(objContext, 0, 0, '', 0, 0, 0)\n                break\n              case 3:\n              //     INTERACTIVE     Downloading; responseText holds partial data.\n              // One character is two bytes\n                bytes_transferred = req.responseText.length * 2\n                notification.call(objContext, 7, 0, '', 0, bytes_transferred, 0)\n                break\n              case 4:\n              //     COMPLETED     The operation is complete.\n                if (req.status >= 200 && req.status < 400) {\n                // One character is two bytes\n                  bytes_transferred = req.responseText.length * 2\n                  notification.call(objContext, 8, 0, '', req.status, bytes_transferred, 0)\n                } else if (req.status === 403) {\n                // Fix: These two are finished except for message\n                  notification.call(objContext, 10, 2, '', req.status, 0, 0)\n                } else {\n                // Errors\n                  notification.call(objContext, 9, 2, '', req.status, 0, 0)\n                }\n                break\n              default:\n                throw 'Unrecognized ready state for file_get_contents()'\n            }\n          }\n        }\n      }\n    }\n\n    if (http_stream) {\n      var sendHeaders = (http_options.header && http_options.header.split(/\\r?\\n/)) || []\n      var userAgentSent = false\n      for (i = 0; i < sendHeaders.length; i++) {\n        var sendHeader = sendHeaders[i]\n        var breakPos = sendHeader.search(/:\\s*/)\n        var sendHeaderName = sendHeader.substring(0, breakPos)\n        req.setRequestHeader(sendHeaderName, sendHeader.substring(breakPos + 1))\n        if (sendHeaderName === 'User-Agent') {\n          userAgentSent = true\n        }\n      }\n      if (!userAgentSent) {\n        var user_agent = http_options.user_agent || (ini.user_agent && ini.user_agent.local_value)\n        if (user_agent) {\n          req.setRequestHeader('User-Agent', user_agent)\n        }\n      }\n      content = http_options.content || null\n      /*\n      // Presently unimplemented HTTP context options\n      // When set to TRUE, the entire URI will be used when constructing the request. (i.e. GET http://www.example.com/path/to/file.html HTTP/1.0). While this is a non-standard request format, some proxy servers require it.\n      var request_fulluri = http_options.request_fulluri || false;\n      // The max number of redirects to follow. Value 1 or less means that no redirects are followed.\n      var max_redirects = http_options.max_redirects || 20;\n      // HTTP protocol version\n      var protocol_version = http_options.protocol_version || 1.0;\n      // Read timeout in seconds, specified by a float\n      var timeout = http_options.timeout || (ini.default_socket_timeout && ini.default_socket_timeout.local_value);\n      // Fetch the content even on failure status codes.\n      var ignore_errors = http_options.ignore_errors || false;\n      */\n    }\n\n    if (flagNames & OPTS.FILE_TEXT) {\n      // Overrides how encoding is treated (regardless of what is returned from the server)\n      var content_type = 'text/html'\n      if (http_options && http_options['phpjs.override']) {\n        // Fix: Could allow for non-HTTP as well\n        // We use this, e.g., in gettext-related functions if character set\n        content_type = http_options['phpjs.override']\n        //   overridden earlier by bind_textdomain_codeset()\n      } else {\n        var encoding = (ini['unicode.stream_encoding'] && ini['unicode.stream_encoding'].local_value) ||\n          'UTF-8'\n        if (http_options && http_options.header && (/^content-type:/im)\n          .test(http_options.header)) {\n          // We'll assume a content-type expects its own specified encoding if present\n          // We let any header encoding stand\n          content_type = http_options.header.match(/^content-type:\\s*(.*)$/im)[1]\n        }\n        if (!(/;\\s*charset=/)\n          .test(content_type)) {\n          // If no encoding\n          content_type += '; charset=' + encoding\n        }\n      }\n      req.overrideMimeType(content_type)\n    }\n    // Default is FILE_BINARY, but for binary, we apparently deviate from PHP in requiring the flag, since many if not\n    //     most people will also want a way to have it be auto-converted into native JavaScript text instead\n    else if (flagNames & OPTS.FILE_BINARY) {\n      // Trick at https://developer.mozilla.org/En/Using_XMLHttpRequest to get binary\n      req.overrideMimeType('text/plain; charset=x-user-defined')\n      // Getting an individual byte then requires:\n      // throw away high-order byte (f7) where x is 0 to responseText.length-1 (see notes in our substr())\n      // responseText.charCodeAt(x) & 0xFF;\n    }\n\n    try {\n      if (http_options && http_options['phpjs.sendAsBinary']) {\n        // For content sent in a POST or PUT request (use with file_put_contents()?)\n        // In Firefox, only available FF3+\n        req.sendAsBinary(content)\n      } else {\n        req.send(content)\n      }\n    } catch (e) {\n      // catches exception reported in issue #66\n      return false\n    }\n\n    tmp = req.getAllResponseHeaders()\n    if (tmp) {\n      tmp = tmp.split('\\n')\n      for (k = 0; k < tmp.length; k++) {\n        if (func(tmp[k])) {\n          newTmp.push(tmp[k])\n        }\n      }\n      tmp = newTmp\n      for (i = 0; i < tmp.length; i++) {\n        headers[i] = tmp[i]\n      }\n      // see http://php.net/manual/en/reserved.variables.httpresponseheader.php\n      this.$http_response_header = headers\n    }\n\n    if (offset || maxLen) {\n      if (maxLen) {\n        return req.responseText.substr(offset || 0, maxLen)\n      }\n      return req.responseText.substr(offset)\n    }\n    return req.responseText\n  }\n  return false\n}\n"
permalink: /functions/file_get_contents/
redirect_from:
  - /functions/filesystem/file_get_contents/
---

<!-- WARNING! This file is auto generated by `npm run web:inject`, do not edit by hand -->
